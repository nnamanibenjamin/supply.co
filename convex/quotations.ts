import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { ConvexError } from "convex/values";
import { internal } from "./_generated/api.js";

// Submit quotation (supplier only)
export const submitQuotation = mutation({
  args: {
    rfqId: v.id("rfqs"),
    productId: v.optional(v.id("products")),
    unitPrice: v.number(),
    deliveryTime: v.string(),
    notes: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError({
        message: "User not logged in",
        code: "UNAUTHENTICATED",
      });
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier))
      .first();

    if (!user || !user.supplierId) {
      throw new ConvexError({
        message: "Only suppliers can submit quotations",
        code: "FORBIDDEN",
      });
    }

    const supplier = await ctx.db.get(user.supplierId);
    if (!supplier || supplier.verificationStatus !== "approved") {
      throw new ConvexError({
        message: "Your supplier account must be approved to submit quotations",
        code: "FORBIDDEN",
      });
    }

    // Get RFQ
    const rfq = await ctx.db.get(args.rfqId);
    if (!rfq) {
      throw new ConvexError({
        message: "RFQ not found",
        code: "NOT_FOUND",
      });
    }

    if (rfq.status !== "open") {
      throw new ConvexError({
        message: "This RFQ is no longer accepting quotations",
        code: "FORBIDDEN",
      });
    }

    // Check if supplier already submitted a quotation
    const existingQuotation = await ctx.db
      .query("quotations")
      .withIndex("by_rfq_and_supplier", (q) =>
        q.eq("rfqId", args.rfqId).eq("supplierId", user.supplierId!)
      )
      .first();

    if (existingQuotation) {
      throw new ConvexError({
        message: "You have already submitted a quotation for this RFQ",
        code: "CONFLICT",
      });
    }

    // Check if supplier has enough credits (cost: 1 credit per quotation)
    if (supplier.credits < 1) {
      throw new ConvexError({
        message: "Insufficient credits. Please purchase more credits to submit quotations.",
        code: "FORBIDDEN",
      });
    }

    // Calculate total price
    const totalPrice = args.unitPrice * rfq.quantity;

    // Create quotation
    const quotationId = await ctx.db.insert("quotations", {
      rfqId: args.rfqId,
      supplierId: user.supplierId,
      productId: args.productId,
      unitPrice: args.unitPrice,
      totalPrice,
      deliveryTime: args.deliveryTime,
      notes: args.notes,
      isAutoGenerated: false,
      status: "pending",
      createdBy: user._id,
    });

    // Deduct 1 credit and record transaction
    await ctx.scheduler.runAfter(0, internal.credits.recordTransaction, {
      supplierId: user.supplierId,
      type: "deduction",
      amount: -1,
      description: `Submitted quotation for RFQ: ${rfq.productName}`,
      rfqId: args.rfqId,
      quotationId,
      processedBy: user._id,
    });

    return quotationId;
  },
});

// Get quotations for an RFQ (hospital only)
export const getRFQQuotations = query({
  args: { rfqId: v.id("rfqs") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError({
        message: "User not logged in",
        code: "UNAUTHENTICATED",
      });
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier))
      .first();

    if (!user || !user.hospitalId) {
      throw new ConvexError({
        message: "Only hospital users can view quotations",
        code: "FORBIDDEN",
      });
    }

    const rfq = await ctx.db.get(args.rfqId);
    if (!rfq) {
      throw new ConvexError({
        message: "RFQ not found",
        code: "NOT_FOUND",
      });
    }

    // Check if user's hospital owns this RFQ
    if (rfq.hospitalId !== user.hospitalId) {
      throw new ConvexError({
        message: "You can only view quotations for your hospital's RFQs",
        code: "FORBIDDEN",
      });
    }

    const quotations = await ctx.db
      .query("quotations")
      .withIndex("by_rfq", (q) => q.eq("rfqId", args.rfqId))
      .order("desc")
      .collect();

    // Get supplier and product details
    const quotationsWithDetails = await Promise.all(
      quotations.map(async (quotation) => {
        const supplier = await ctx.db.get(quotation.supplierId);
        const product = quotation.productId
          ? await ctx.db.get(quotation.productId)
          : null;

        return {
          ...quotation,
          supplier,
          product,
        };
      })
    );

    return quotationsWithDetails;
  },
});

// Accept quotation (hospital only)
export const acceptQuotation = mutation({
  args: { quotationId: v.id("quotations") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError({
        message: "User not logged in",
        code: "UNAUTHENTICATED",
      });
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier))
      .first();

    if (!user || !user.hospitalId) {
      throw new ConvexError({
        message: "Only hospital users can accept quotations",
        code: "FORBIDDEN",
      });
    }

    const quotation = await ctx.db.get(args.quotationId);
    if (!quotation) {
      throw new ConvexError({
        message: "Quotation not found",
        code: "NOT_FOUND",
      });
    }

    const rfq = await ctx.db.get(quotation.rfqId);
    if (!rfq) {
      throw new ConvexError({
        message: "RFQ not found",
        code: "NOT_FOUND",
      });
    }

    // Check if user's hospital owns this RFQ
    if (rfq.hospitalId !== user.hospitalId) {
      throw new ConvexError({
        message: "You can only accept quotations for your hospital's RFQs",
        code: "FORBIDDEN",
      });
    }

    // Update quotation status
    await ctx.db.patch(args.quotationId, { status: "accepted" });

    // Update RFQ status to fulfilled
    await ctx.db.patch(quotation.rfqId, { status: "fulfilled" });

    // Reject all other quotations for this RFQ
    const otherQuotations = await ctx.db
      .query("quotations")
      .withIndex("by_rfq", (q) => q.eq("rfqId", quotation.rfqId))
      .collect();

    for (const other of otherQuotations) {
      if (other._id !== args.quotationId && other.status === "pending") {
        await ctx.db.patch(other._id, { status: "rejected" });
      }
    }

    return { success: true };
  },
});

// Get supplier's quotations
export const getSupplierQuotations = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError({
        message: "User not logged in",
        code: "UNAUTHENTICATED",
      });
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier))
      .first();

    if (!user || !user.supplierId) {
      throw new ConvexError({
        message: "Only suppliers can view quotations",
        code: "FORBIDDEN",
      });
    }

    const quotations = await ctx.db
      .query("quotations")
      .withIndex("by_supplier", (q) => q.eq("supplierId", user.supplierId!))
      .order("desc")
      .collect();

    // Get RFQ and hospital details
    const quotationsWithDetails = await Promise.all(
      quotations.map(async (quotation) => {
        const rfq = await ctx.db.get(quotation.rfqId);
        const hospital = rfq ? await ctx.db.get(rfq.hospitalId) : null;
        const product = quotation.productId
          ? await ctx.db.get(quotation.productId)
          : null;

        return {
          ...quotation,
          rfq,
          hospital,
          product,
        };
      })
    );

    return quotationsWithDetails;
  },
});
