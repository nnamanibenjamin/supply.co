import { v } from "convex/values";
import { mutation, query } from "./_generated/server";
import { ConvexError } from "convex/values";
import { internal } from "./_generated/api.js";

// Submit quotation (supplier only)
export const submitQuotation = mutation({
  args: {
    rfqId: v.id("rfqs"),
    productId: v.optional(v.id("products")),
    unitPrice: v.number(),
    deliveryTime: v.string(),
    notes: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError({
        message: "User not logged in",
        code: "UNAUTHENTICATED",
      });
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier))
      .first();

    if (!user || !user.supplierId) {
      throw new ConvexError({
        message: "Only suppliers can submit quotations",
        code: "FORBIDDEN",
      });
    }

    const supplier = await ctx.db.get(user.supplierId);
    if (!supplier || supplier.verificationStatus !== "approved") {
      throw new ConvexError({
        message: "Your supplier account must be approved to submit quotations",
        code: "FORBIDDEN",
      });
    }

    // Get RFQ
    const rfq = await ctx.db.get(args.rfqId);
    if (!rfq) {
      throw new ConvexError({
        message: "RFQ not found",
        code: "NOT_FOUND",
      });
    }

    if (rfq.status !== "open") {
      throw new ConvexError({
        message: "This RFQ is no longer accepting quotations",
        code: "FORBIDDEN",
      });
    }

    // Check if supplier already submitted a quotation
    const existingQuotation = await ctx.db
      .query("quotations")
      .withIndex("by_rfq_and_supplier", (q) =>
        q.eq("rfqId", args.rfqId).eq("supplierId", user.supplierId!)
      )
      .first();

    if (existingQuotation) {
      throw new ConvexError({
        message: "You have already submitted a quotation for this RFQ",
        code: "CONFLICT",
      });
    }

    // Check if supplier has enough credits (cost: 1 credit per quotation)
    if (supplier.credits < 1) {
      throw new ConvexError({
        message: "Insufficient credits. Please purchase more credits to submit quotations.",
        code: "FORBIDDEN",
      });
    }

    // Calculate total price
    const totalPrice = args.unitPrice * rfq.quantity;

    // Create quotation
    const quotationId = await ctx.db.insert("quotations", {
      rfqId: args.rfqId,
      supplierId: user.supplierId,
      productId: args.productId,
      unitPrice: args.unitPrice,
      totalPrice,
      deliveryTime: args.deliveryTime,
      notes: args.notes,
      isAutoGenerated: false,
      status: "pending",
      createdBy: user._id,
    });

    // Deduct 1 credit and record transaction
    await ctx.scheduler.runAfter(0, internal.credits.recordTransaction, {
      supplierId: user.supplierId,
      type: "deduction",
      amount: -1,
      description: `Submitted quotation for RFQ: ${rfq.productName}`,
      rfqId: args.rfqId,
      quotationId,
      processedBy: user._id,
    });

    // Notify hospital about new quotation
    const hospital = await ctx.db.get(rfq.hospitalId);
    if (hospital) {
      await ctx.scheduler.runAfter(0, internal.notifications.notifyHospitalAboutQuotation, {
        quotationId,
        rfqId: args.rfqId,
        hospitalId: rfq.hospitalId,
        supplierName: supplier.companyName,
        productName: rfq.productName,
        totalPrice,
      });
    }

    return quotationId;
  },
});

// Get quotations for an RFQ (hospital only)
export const getRFQQuotations = query({
  args: { rfqId: v.id("rfqs") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError({
        message: "User not logged in",
        code: "UNAUTHENTICATED",
      });
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier))
      .first();

    if (!user || !user.hospitalId) {
      throw new ConvexError({
        message: "Only hospital users can view quotations",
        code: "FORBIDDEN",
      });
    }

    const rfq = await ctx.db.get(args.rfqId);
    if (!rfq) {
      throw new ConvexError({
        message: "RFQ not found",
        code: "NOT_FOUND",
      });
    }

    // Check if user's hospital owns this RFQ
    if (rfq.hospitalId !== user.hospitalId) {
      throw new ConvexError({
        message: "You can only view quotations for your hospital's RFQs",
        code: "FORBIDDEN",
      });
    }

    const quotations = await ctx.db
      .query("quotations")
      .withIndex("by_rfq", (q) => q.eq("rfqId", args.rfqId))
      .order("desc")
      .collect();

    // Get supplier and product details
    const quotationsWithDetails = await Promise.all(
      quotations.map(async (quotation) => {
        const supplier = await ctx.db.get(quotation.supplierId);
        const product = quotation.productId
          ? await ctx.db.get(quotation.productId)
          : null;

        return {
          ...quotation,
          supplier,
          product,
        };
      })
    );

    return quotationsWithDetails;
  },
});

// Accept quotation (hospital only)
export const acceptQuotation = mutation({
  args: { quotationId: v.id("quotations") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError({
        message: "User not logged in",
        code: "UNAUTHENTICATED",
      });
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier))
      .first();

    if (!user || !user.hospitalId) {
      throw new ConvexError({
        message: "Only hospital users can accept quotations",
        code: "FORBIDDEN",
      });
    }

    const quotation = await ctx.db.get(args.quotationId);
    if (!quotation) {
      throw new ConvexError({
        message: "Quotation not found",
        code: "NOT_FOUND",
      });
    }

    const rfq = await ctx.db.get(quotation.rfqId);
    if (!rfq) {
      throw new ConvexError({
        message: "RFQ not found",
        code: "NOT_FOUND",
      });
    }

    // Check if user's hospital owns this RFQ
    if (rfq.hospitalId !== user.hospitalId) {
      throw new ConvexError({
        message: "You can only accept quotations for your hospital's RFQs",
        code: "FORBIDDEN",
      });
    }

    // Update quotation status
    await ctx.db.patch(args.quotationId, { status: "accepted" });

    // Update RFQ status to fulfilled
    await ctx.db.patch(quotation.rfqId, { status: "fulfilled" });

    // Notify supplier about acceptance
    const hospital = await ctx.db.get(rfq.hospitalId);
    if (hospital) {
      await ctx.scheduler.runAfter(0, internal.notifications.notifySupplierAboutQuotationStatus, {
        quotationId: args.quotationId,
        supplierId: quotation.supplierId,
        status: "accepted",
        hospitalName: hospital.name,
        productName: rfq.productName,
      });
    }

    // Reject all other quotations for this RFQ
    const otherQuotations = await ctx.db
      .query("quotations")
      .withIndex("by_rfq", (q) => q.eq("rfqId", quotation.rfqId))
      .collect();

    for (const other of otherQuotations) {
      if (other._id !== args.quotationId && other.status === "pending") {
        await ctx.db.patch(other._id, { status: "rejected" });
        
        // Notify supplier about rejection
        if (hospital) {
          await ctx.scheduler.runAfter(0, internal.notifications.notifySupplierAboutQuotationStatus, {
            quotationId: other._id,
            supplierId: other.supplierId,
            status: "rejected",
            hospitalName: hospital.name,
            productName: rfq.productName,
          });
        }
      }
    }

    return { success: true };
  },
});

// Get supplier's quotations
export const getSupplierQuotations = query({
  args: {
    status: v.optional(
      v.union(v.literal("pending"), v.literal("accepted"), v.literal("rejected"))
    ),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError({
        message: "User not logged in",
        code: "UNAUTHENTICATED",
      });
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier))
      .first();

    if (!user || !user.supplierId) {
      throw new ConvexError({
        message: "Only suppliers can view quotations",
        code: "FORBIDDEN",
      });
    }

    const quotations = await ctx.db
      .query("quotations")
      .withIndex("by_supplier", (q) =>
        args.status
          ? q.eq("supplierId", user.supplierId!).eq("status", args.status)
          : q.eq("supplierId", user.supplierId!)
      )
      .order("desc")
      .collect();

    // Get RFQ and hospital details
    const quotationsWithDetails = await Promise.all(
      quotations.map(async (quotation) => {
        const rfq = await ctx.db.get(quotation.rfqId);
        const hospital = rfq ? await ctx.db.get(rfq.hospitalId) : null;
        const product = quotation.productId
          ? await ctx.db.get(quotation.productId)
          : null;

        return {
          ...quotation,
          rfq,
          hospital,
          product,
        };
      })
    );

    return quotationsWithDetails;
  },
});

// Get single quotation details
export const getQuotation = query({
  args: { quotationId: v.id("quotations") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError({
        message: "User not logged in",
        code: "UNAUTHENTICATED",
      });
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier))
      .first();

    if (!user) {
      throw new ConvexError({
        message: "User not found",
        code: "NOT_FOUND",
      });
    }

    const quotation = await ctx.db.get(args.quotationId);
    if (!quotation) {
      throw new ConvexError({
        message: "Quotation not found",
        code: "NOT_FOUND",
      });
    }

    // Check access permissions
    if (user.accountType === "supplier") {
      if (quotation.supplierId !== user.supplierId) {
        throw new ConvexError({
          message: "You can only view your own quotations",
          code: "FORBIDDEN",
        });
      }
    } else if (user.accountType === "hospital" || user.accountType === "hospital_staff") {
      const rfq = await ctx.db.get(quotation.rfqId);
      if (!rfq || rfq.hospitalId !== user.hospitalId) {
        throw new ConvexError({
          message: "You can only view quotations for your hospital's RFQs",
          code: "FORBIDDEN",
        });
      }
    } else {
      throw new ConvexError({
        message: "Access denied",
        code: "FORBIDDEN",
      });
    }

    // Get related data
    const rfq = await ctx.db.get(quotation.rfqId);
    const supplier = await ctx.db.get(quotation.supplierId);
    const hospital = rfq ? await ctx.db.get(rfq.hospitalId) : null;
    const product = quotation.productId
      ? await ctx.db.get(quotation.productId)
      : null;

    return {
      ...quotation,
      rfq,
      supplier,
      hospital,
      product,
    };
  },
});

// Update quotation (supplier only, before acceptance)
export const updateQuotation = mutation({
  args: {
    quotationId: v.id("quotations"),
    unitPrice: v.number(),
    deliveryTime: v.string(),
    notes: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError({
        message: "User not logged in",
        code: "UNAUTHENTICATED",
      });
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier))
      .first();

    if (!user || !user.supplierId) {
      throw new ConvexError({
        message: "Only suppliers can update quotations",
        code: "FORBIDDEN",
      });
    }

    const quotation = await ctx.db.get(args.quotationId);
    if (!quotation) {
      throw new ConvexError({
        message: "Quotation not found",
        code: "NOT_FOUND",
      });
    }

    // Verify ownership
    if (quotation.supplierId !== user.supplierId) {
      throw new ConvexError({
        message: "You can only update your own quotations",
        code: "FORBIDDEN",
      });
    }

    // Can only update pending quotations
    if (quotation.status !== "pending") {
      throw new ConvexError({
        message: "Cannot update a quotation that has been accepted or rejected",
        code: "FORBIDDEN",
      });
    }

    // Verify RFQ is still open
    const rfq = await ctx.db.get(quotation.rfqId);
    if (!rfq || rfq.status !== "open") {
      throw new ConvexError({
        message: "Cannot update quotation for a closed RFQ",
        code: "FORBIDDEN",
      });
    }

    // Calculate new total price
    const totalPrice = args.unitPrice * rfq.quantity;

    // Update quotation
    await ctx.db.patch(args.quotationId, {
      unitPrice: args.unitPrice,
      totalPrice,
      deliveryTime: args.deliveryTime,
      notes: args.notes,
    });

    return { success: true };
  },
});

// Withdraw quotation (supplier only, before acceptance)
export const withdrawQuotation = mutation({
  args: { quotationId: v.id("quotations") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError({
        message: "User not logged in",
        code: "UNAUTHENTICATED",
      });
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier))
      .first();

    if (!user || !user.supplierId) {
      throw new ConvexError({
        message: "Only suppliers can withdraw quotations",
        code: "FORBIDDEN",
      });
    }

    const quotation = await ctx.db.get(args.quotationId);
    if (!quotation) {
      throw new ConvexError({
        message: "Quotation not found",
        code: "NOT_FOUND",
      });
    }

    // Verify ownership
    if (quotation.supplierId !== user.supplierId) {
      throw new ConvexError({
        message: "You can only withdraw your own quotations",
        code: "FORBIDDEN",
      });
    }

    // Can only withdraw pending quotations
    if (quotation.status !== "pending") {
      throw new ConvexError({
        message: "Cannot withdraw a quotation that has been accepted or rejected",
        code: "FORBIDDEN",
      });
    }

    // Delete the quotation
    await ctx.db.delete(args.quotationId);

    // Refund the credit
    const rfq = await ctx.db.get(quotation.rfqId);
    await ctx.scheduler.runAfter(0, internal.credits.recordTransaction, {
      supplierId: user.supplierId,
      type: "refund",
      amount: 1,
      description: `Refund for withdrawn quotation: ${rfq?.productName || "RFQ"}`,
      rfqId: quotation.rfqId,
      quotationId: args.quotationId,
      processedBy: user._id,
    });

    return { success: true };
  },
});

// Reject quotation (hospital only)
export const rejectQuotation = mutation({
  args: { quotationId: v.id("quotations") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError({
        message: "User not logged in",
        code: "UNAUTHENTICATED",
      });
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_token", (q) => q.eq("tokenIdentifier", identity.tokenIdentifier))
      .first();

    if (!user || !user.hospitalId) {
      throw new ConvexError({
        message: "Only hospital users can reject quotations",
        code: "FORBIDDEN",
      });
    }

    const quotation = await ctx.db.get(args.quotationId);
    if (!quotation) {
      throw new ConvexError({
        message: "Quotation not found",
        code: "NOT_FOUND",
      });
    }

    const rfq = await ctx.db.get(quotation.rfqId);
    if (!rfq) {
      throw new ConvexError({
        message: "RFQ not found",
        code: "NOT_FOUND",
      });
    }

    // Check if user's hospital owns this RFQ
    if (rfq.hospitalId !== user.hospitalId) {
      throw new ConvexError({
        message: "You can only reject quotations for your hospital's RFQs",
        code: "FORBIDDEN",
      });
    }

    // Can only reject pending quotations
    if (quotation.status !== "pending") {
      throw new ConvexError({
        message: "Quotation has already been accepted or rejected",
        code: "FORBIDDEN",
      });
    }

    // Update quotation status
    await ctx.db.patch(args.quotationId, { status: "rejected" });

    // Notify supplier about rejection
    const hospital = await ctx.db.get(rfq.hospitalId);
    if (hospital) {
      await ctx.scheduler.runAfter(0, internal.notifications.notifySupplierAboutQuotationStatus, {
        quotationId: args.quotationId,
        supplierId: quotation.supplierId,
        status: "rejected",
        hospitalName: hospital.name,
        productName: rfq.productName,
      });
    }

    return { success: true };
  },
});
